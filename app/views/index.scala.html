@(message: String)

@jsContent = {
    <script>
        var serverPhrases = [];

        var $inputTextToTranslate = $("#input-text-to-translate");
        var $inputTranslated = $("#input-translated");
        var $divRequestResult = $("#div-request-result");

        var treeRoot = null;
        var currentNode = null;
        var currentNodeCharIndex = null;
        var lastCompletedNode = null;
        var expectSpace = false;
        var currentPhraseInput = "";

        var originalPhrase = null;
        var matchedPhrases = null;

        String.prototype.capitalizeFirstLetter = function() {
            return this.charAt(0).toUpperCase() + this.slice(1);
        };

        $(document).ready(function() {
            $("#button-request-translation").click(function(e) {
                originalPhrase = $inputTextToTranslate.val();
                console.log("Translating: " + originalPhrase);
                $("#input-translated").val("");

                $.get("/suggestions", {
                    sentence: originalPhrase
                }, function (data) {
                    console.log("Received from server:");
                    console.log(data);

                    $divRequestResult.empty();
                    $divRequestResult.append(
                            "<p>" +
                            "Received " + data.length + " suggestions." +
                            "</p>"
                    );

                    serverPhrases = data;
                    refreshAutocomplete();
                });

                e.preventDefault();
            });

            function refreshAutocomplete() {
                $("#table-autocomplete").empty();
                $("#table-autocomplete").append(
                        "<tr><th>Key</th><th>Word</th><th>Probability</th></tr>"
                );

                var grouped;
                if (matchedPhrases != null) {
                    var originalPhraseLength = originalPhrase.split(" ").length;
                    treeRoot = new TreeNode(matchedPhrases, [], []);
                    for (var i = 0; i < originalPhraseLength; i++) {
                        treeRoot.translated.push(false);
                    }
                    for (var j = 0; j < matchedPhrases.length; j++) {
                        for (var i = matchedPhrases[j].beginIndex; i <= matchedPhrases[j].endIndex; i++) {
                            treeRoot.translated[i] = true;
                        }
                    }
                }
                buildTree();

                var matchedPhrasesLength = matchedPhrases == null ? 0 : matchedPhrases.length;
                grouped = groupAndSortTreeNodesByPhraseTranslation(Math.max(matchedPhrasesLength, 0), treeRoot.getLastStepChildren());

                var words = $inputTranslated.val().split(" ");
                var filter = words[words.length - 1];
                console.log("Filter suggestions by: " + filter);
                var filtered = grouped.filter(function (phrase) {
                    return phrase[0].startsWith(filter);
                });

                var keys = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];
                for(var i = 0; i < keys.length && i < filtered.length; i++) {
                    $("#table-autocomplete").append(
                            "<tr><td>" + keys[i] + "</td><td>" + filtered[i][0] + "</td><td>" + filtered[i][1] + "</td></tr>"
                    );
                }

                /*
                autocompleteList = [];

                var translated = $inputTranslated.val().replace(/[,.]/g, "").toLowerCase();
                var translatedWords = translated.split(" ");
                var translatedLastWord = translatedWords[translatedWords.length - 1];

                var filtered = [];
                var filteredIndex = [];

                for(var i = 0; i < serverReply.length; i++) {
                    if(serverReply[i].translation.startsWith(translatedLastWord)) {
                        filtered.push(serverReply[i]);
                        filteredIndex.push(i);
                    }
                }

                console.log("Filtered hypothesis: ");
                console.log(filtered);

                for(var i = 0; i < filtered.length; i++) {
                    autocompleteList.push({
                        word: filtered[i].translation,
                        index: filteredIndex[i]
                    });
                }

                var keys = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"];
                for(var i = 0; i < autocompleteList.length && i < keys.length; i++) {
                    $("#table-autocomplete").append(
                            "<tr><td>" + keys[i] + "</td><td>" + autocompleteList[i].word + "</td><td>" + autocompleteList[i].index + "</td></tr>"
                    );
                }
                */
            }

            (function() {
                // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
                //var keys = [49, 50, 51, 52, 53, 54, 55, 56, 57, 58];

                $inputTranslated.keypress(function (event) {
                    var inChar = String.fromCharCode(event.which);

                    /*
                    if (treeRoot != null) {
                        if (currentNodeCharIndex == null && !(expectSpace && inChar != " ")) {
                            if (inChar == " ") {
                                if (expectSpace) {
                                    expectSpace = false;
                                    console.log("Got space.");
                                } else {
                                    console.log("Ignoring whitespace.");
                                }
                            } else {
                                // Looking for the next child node.
                                console.log("Looking for a new next node.");
                                for (var i = 0; i < currentNode.children.length; i++) {
                                    if(currentNode.children[i].getLastPhrase().translation.startsWith(inChar)) {
                                        console.log("Found a new node with translation: " + currentNode.children[i].getLastPhrase().translation);
                                        lastCompletedNode = currentNode;
                                        currentNode = currentNode.children[i];

                                        currentNodeCharIndex = 1;
                                        currentPhraseInput = inChar;
                                        if(currentNodeCharIndex >= currentNode.getLastPhrase().translation.length) {
                                            currentNodeCharIndex = null;
                                            expectSpace = true;
                                        }

                                        break;
                                    }
                                }
                            }
                        } else {
                            currentPhraseInput += inChar;

                            // Verify if character matches the one supposed to be in the node.
                            if (currentNodeCharIndex != null && currentNode.getLastPhrase().translation[currentNodeCharIndex] == inChar) {
                                // Ok.
                                console.log("Character entered matches phrase translation '" + currentNode.getLastPhrase().translation + "'.");
                                currentNodeCharIndex += 1;
                                if(currentNodeCharIndex >= currentNode.getLastPhrase().translation.length) {
                                    currentNodeCharIndex = null;
                                    expectSpace = true;
                                }
                            } else {
                                // Generate all possible nodes here and try to look in them as well.
                                var regenerate = true;
                                if(lastCompletedNode != null) {
                                    console.log("--");
                                    console.log("Looking for a new child from previous node with prefix '" + currentPhraseInput + "'.");
                                    console.log("Prev node:");
                                    console.log(lastCompletedNode);
                                    console.log("--");
                                    for (var i = 0; i < lastCompletedNode.children.length; i++) {
                                        if(lastCompletedNode.children[i].getLastPhrase().translation.startsWith(currentPhraseInput)
                                                || lastCompletedNode.children[i].getLastPhrase().translation.startsWith(currentPhraseInput.slice(0, -1))) {
                                            console.log("Found a new node replacement with translation: " + lastCompletedNode.children[i].getLastPhrase().translation);
                                            currentNode = lastCompletedNode.children[i];

                                            currentNodeCharIndex += 1;
                                            if(currentNodeCharIndex >= currentNode.getLastPhrase().translation.length) {
                                                currentNodeCharIndex = null;
                                                expectSpace = true;
                                            }

                                            regenerate = false;
                                            break;
                                        }

                                        //TEST: to go deeper
                                        if(currentPhraseInput.startsWith(lastCompletedNode.children[i].getLastPhrase().translation)) {
                                            var length = lastCompletedNode.children[i].getLastPhrase().translation.length;
                                            var node = lastCompletedNode.children[i];

                                            var doBreak = false;
                                            for (var j = 0; j < node.children.length; j++) {
                                                // Remove whitespace between phrase
                                                var test11 = node.children[j].getLastPhrase().translation;
                                                var test12 = currentPhraseInput.slice(length + 1, currentPhraseInput.length);
                                                var test1 = test11.startsWith(test12);
                                                var test2 = currentPhraseInput.length <= length + 1 + node.children[j].getLastPhrase().translation.length;

                                                if(node.children[j].getLastPhrase().translation.startsWith(currentPhraseInput.slice(length + 1, currentPhraseInput.length))
                                                    && currentPhraseInput.length <= length + 1 + node.children[j].getLastPhrase().translation.length) {
                                                    console.log("!deep! Found a new node replacement with translation: " + node.getLastPhrase().translation + "_" + node.children[j].getLastPhrase().translation);
                                                    currentNode = node.children[j];

                                                    currentNodeCharIndex = currentPhraseInput.length - (length + 1);
                                                    if(currentNodeCharIndex >= currentNode.getLastPhrase().translation.length) {
                                                        currentNodeCharIndex = null;
                                                    }
                                                    doBreak = true;
                                                    regenerate = false;
                                                    break;
                                                }
                                            }
                                            if (doBreak) {
                                                break;
                                            }
                                        }
                                    }
                                }

                                if (regenerate) {
                                    console.log("Doesn't match any nodes. Updating translation matrix (NOT) and will generate new tree. (NOT)");
                                    treeRoot = null;
                                    currentNode = null;
                                    currentNodeCharIndex = null;
                                }
                            }
                        }
                    }
                    */

                    /*
                    for (var i = 0; i < keys.length; i++) {
                        if (event.which == keys[i] && i < autocompleteList.length) {
                            console.log("pressed key " + keys[i]);
                            event.preventDefault();

                            var words = $inputTranslated.val().split(" ");
                            words.pop();

                            if(words.length > 0) {
                                $inputTranslated.val(words.join(" ") + " " + autocompleteList[i].word + " ");
                            } else {
                                $inputTranslated.val(autocompleteList[i].word.capitalizeFirstLetter() + " ");
                            }
                            suggestionsUsed.push(autocompleteList[i].index);
                            refreshAutocomplete();
                        }
                    }
                    */
                });

                /*
                $("#input-translated").on("input", function (event) {
                    console.log("Running refresh autocomplete because on change event called.");
                    refreshAutocomplete();
                });
                */

                $("#input-translated").on("input", function (event) {
                    matchedPhrases = [];

                    var words = $inputTranslated.val().split(" ");
                    for (var j = 0; j < words.length - 1; j++) {
                        for (var end = words.length - 1; end > j; end--) {
                            // from j to i try to match phrase

                            var tryToMatch = words.slice(j, end).join(" ");
                            //console.log("Trying from " + j + " to " + end + " to match: '" + tryToMatch + "'.");

                            for (var k = 0; k < serverPhrases.length; k++) {
                                if (serverPhrases[k].translation == tryToMatch) {
                                    console.log("--Matched '" +  tryToMatch + "' with '" + serverPhrases[k].original + "' from server phrase.--");
                                    matchedPhrases.push(serverPhrases[k]);
                                    j += (end - j - 1);
                                    i = words.length;
                                    break;
                                }
                            }
                        }
                    }

                    console.log("Result:");
                    console.log(matchedPhrases);
                    refreshAutocomplete();
                });
            })();

            // Source: http://stackoverflow.com/questions/5199901/how-to-sort-an-associative-array-by-its-values-in-javascript
            function bySortedValue(obj, callback, context) {
                var tuples = [];

                for (var key in obj) tuples.push([key, obj[key]]);

                tuples.sort(function(a, b) { return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0 });

                var length = tuples.length;
                while (length--) callback.call(context, tuples[length][0], tuples[length][1]);
            }

            class TreeNode {
                constructor(phrases, translated, children) {
                    this.phrases = phrases;
                    this.translated = translated;
                    this.children = children;
                    this.probability = 1.0;
                }

                addPhrase(phrase) {
                    this.phrases.push(phrase);
                    for (var i = phrase.beginIndex; i <= phrase.endIndex; i++) {
                        this.translated[i] = true;
                    }
                    this.probability *= phrase.directProbability;
                };

                generateChildren(serverPhrases, iterations) {
                    // Generate all next phrases for this node.
                    var newChildren = [];
                    for (var j = 0; j < serverPhrases.length; j++) {
                        var phrase = serverPhrases[j];
                        var ok = true;
                        for (var i = phrase.beginIndex; i <= phrase.endIndex; i++) {
                            if(this.translated[i] == true) {
                                ok = false;
                                break;
                            }
                        }
                        if(!ok) {
                            continue;
                        }

                        var nextNode = new TreeNode(
                                this.phrases.slice(0),
                                this.translated.slice(0),
                                []
                        );

                        nextNode.addPhrase(phrase);

                        newChildren.push(nextNode);

                        if(newChildren.length >= 50) {
                            break;
                        }
                    }
                    this.children = newChildren;

                    // Trim sorted phrases to top X.
                    this.children.sort(function (a, b) {
                        return b.probability - a.probability;
                    });
                    this.children = this.children.slice(0, 50);

                    if (iterations - 1 > 0 || this.children.length == 0) {
                        // Generate next phrases for all new children.
                        for (var j = 0; j < this.children.length; j++) {
                            this.children[j].generateChildren(serverPhrases, iterations - 1);
                        }
                    }
                };

                getLastStepChildren() {
                    if(this.children.length == 0) {
                        return [this];
                    } else {
                        var out = [];
                        for (var j = 0; j < this.children.length; j++) {
                            var children = this.children[j].getLastStepChildren();
                            for (var i = 0; i < children.length; i++) {
                                out.push(children[i]);
                            }
                        }
                        return out;
                    }
                };

                getLastPhrase() {
                    if (this.phrases.length == 0) {
                        return null;
                    } else {
                        return this.phrases[this.phrases.length - 1];
                    }
                };
            };

            function groupAndSortTreeNodesByPhraseTranslation(index, treeNodes) {
                var firstPhraseGrouped = {};
                treeNodes.map(function (treeNode) {
                    if (treeNode.phrases[index].translation in firstPhraseGrouped) {
                        firstPhraseGrouped[treeNode.phrases[index].translation] += treeNode.probability;
                    } else {
                        firstPhraseGrouped[treeNode.phrases[index].translation] = treeNode.probability;
                    }
                });

                var tuples = [];
                for (var key in firstPhraseGrouped) {
                    tuples.push([key, firstPhraseGrouped[key]]);
                }

                tuples.sort(function(a, b) {
                    a = a[1];
                    b = b[1];

                    return a > b ? -1 : (a < b ? 1 : 0);
                });

                return tuples;

                /*
                for (var i = 0; i < tuples.length; i++) {
                    var key = tuples[i][0];
                    var value = tuples[i][1];

                    // do something with key and value
                }
                */

                /*
                bySortedValue(firstPhraseGrouped, function(a, b) {
                    console.log(a + " " + b);
                });
                */
            }

            function buildTree() {
                var startTime = Date.now();

                // Sort server phrases by probability.
                serverPhrases.sort(function (a, b) {
                    return b.directProbability - a.directProbability;
                });

                if (treeRoot == null) {
                    var originalPhraseLength = originalPhrase.split(" ").length;
                    treeRoot = new TreeNode([], [], []);
                    for (var i = 0; i < originalPhraseLength; i++) {
                        treeRoot.translated.push(false);
                    }
                    currentNode = treeRoot;
                    currentNodeCharIndex = null;
                    lastCompletedNode = null;
                    expectSpace = false;
                }
                treeRoot.generateChildren(serverPhrases, 3);

                elapsedTime = Date.now() - startTime;
                console.log("Build tree timing: " + elapsedTime);

                /*
                console.log("treeRoot: ");
                console.log(treeRoot);

                console.log("last step phrases: ");
                console.log(treeRoot.getLastStepChildren());

                console.log("grouped: ");
                console.log(groupAndSortTreeNodesByPhraseTranslation(0, treeRoot.getLastStepChildren()));
                */
            }
        });
    </script>
}

@main("Phrases Dictionary Prototype", jsContent) {
    <div class="container">
        <div class="row">
            <h3>1. Enter sentence you wish to translate:</h3>
            <div class="col-md-12">
                <input type="text" class="form-control" id="input-text-to-translate" value="convention on the elimination of double taxation">
            </div>
        </div>

        <div class="row">
            <h3>2. Request suggestions for the sentence from server.</h3>
            <div class="col-md-12">
                <div class="row">
                    <div class="col-md-12">
                        <button type="button" class="btn btn-lg btn-success" id="button-request-translation">Request</button>
                    </div>
                </div>
                <div class="row" style="padding-top: 20px;">
                    <div class="col-md-12" id="div-request-result">
                        <p>Nothing requested.</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <h3>3. Start translating</h3>
            <div class="col-md-12">
                <input type="text" class="form-control" id="input-translated">
            </div>
        </div>

        <div class="row">
            <br />
            <div class="col-md-6">
                <table class="table table-bordered table-hover" id="table-autocomplete">
                    <tr>
                        <th>Key</th>
                        <th>Word</th>
                        <th>Probability</th>
                    </tr>
                </table>
            </div>
        </div>
    </div><!-- /.container -->
}
